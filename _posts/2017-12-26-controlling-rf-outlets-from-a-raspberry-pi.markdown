---
layout: post
title: "Controlling RF outlets from a Raspberry Pi"
date: 2017-12-26 00:10
og_image: /img/2017/12/rf_prototype.jpg
description: "For less than $100, my Google Home lets me talk to my floor lamps - even though they aren't very bright ü•Å"
comments: true
categories:
---

[IKEA floor lamps](http://www.ikea.com/ca/en/catalog/products/10139879/) aren't bad - as long as your house has sufficient outlets with properly wired and positioned wall switches. Mine doesn't üòê and, being a renter, I can't simply rewire them, so I decided to try the [Etekcity RF-controlled outlet kit](https://www.ebay.ca/itm/182259352786).

For less than CAD$ 60 you get five outlets, which can be turned on and off individually by the two included remotes. Not a bad deal, and sure an improvement from the odd switches (and the built-in ones on the lamps). But given I already [control my TV and sound bar from Google Home with a Raspberry Pi](https://chester.me/archives/2017/12/voice-control-for-a-non-smart-tv-with-google-home-raspberry-pi-lirc-nginx-lua-ifttt/), it wouldn't be much of a stretch to also have voice control over the lights.

![outlets](/img/2017/12/rf_outlets.jpg){: .center }

<!--more-->

The TV/sound bar hack started with plugging an IR receiver to the RPi, so it could "learn" the IR frequencies for each button on the remote, and then an IR transmitter to simulate the remote buttons when the Pi gets a command from Google Home (via IFTTT).

This one worked roughly the same way, except that, instead of IR, I'd use a 433MHz RF [transmitter/receiver](http://www.dx.com/p/rf-transmitter-receiver-module-433mhz-wireless-link-kit-w-spring-antennas-for-arduino-399919#.WkGs6ktOmRs) pair, controlled by easy-to-use software from [NinjaBlocks](https://ninjablocks.com/).

I mostly followed [Kurt Tomilinson's tutorial](https://blog.kurttomlinson.com/posts/raspberry-pi-projects-you-can-actually-do-part-4-home-automation-with-siri-and-a-raspberry-pi) for the hardware part. In short:

- Wire GND on transmitter and receiver to any GND pin on the RPi;
- Wire VCC on transmitter and receiver to any 5V pin on the RPi;
- Wire the remaining transmitter pin (DATA) to RPi pin 11 (BCM 17) and either of the receiver remaining pins (they are connected) to RPi pin 13 (BCM 27);
- Solder a 17.3cm wire (I used AWG 22, anything stiff will do) to the transmitter as an antenna.

![prototype](/img/2017/12/rf_prototype.jpg){: .center }

Software-wise, we need to compile [NinjaBlocks' 433Utils](https://github.com/ninjablocks/433Utils) so we have two utilities: `RFSniffer` (to learn the codes for each button on the remote) and `codesend` (to send those codes to the outlets at our will). The tutorial shows how to do that, but I added a couple twists:

- Instead of building the [WiringPi](http://wiringpi.com/) library, we can install it from a package;
- Instead of running utilities as root (with `sudo`) we can add the users that need to run them to the `gpio` group.

TL;DR: Here is how I set up the software on the Raspberry Pi:

```bash
cd ~
sudo apt-get install git wiringpi
git clone --recursive git://github.com/ninjablocks/433Utils.git
cd ./433Utils/RPi_utils
make
sudo mv ./codesend /usr/bin/
sudo mv ./RFSniffer /usr/bin/
sudo adduser $USER gpio         # so you can use them them on the command line
sudo adduser www-data gpio      # so the web server (nginx) can also send codes
```

With this, I could run `RFSniffer` and take notes of the numeric codes generated by each button on the remote. Then I could run `codesend NNNNNNN -l 200`, which will simulate the keypress of the button that matches code `NNNNNNN` for 200ms and turn the outlets on and off at will.

At this point, the lights could be controlled by any software (and I didn't need need the receiver anymore). I already had a web server set up to securely run [Lua](http://www.lua.org/) code (see [previous post](https://chester.me/archives/2017/12/voice-control-for-a-non-smart-tv-with-google-home-raspberry-pi-lirc-nginx-lua-ifttt/)), so I just cooked a function that, given a light and a state ("on" or "off") would execute `codesend` with the proper code (no, those aren't my codes):

```lua
light = function(which, state)
  codes_on = { 5538945, 2436560, 4296666, 8345444, 0212408 }
  codes_off = { 7152607, 1929488, 4714537, 8798718, 1585774 }
  if state == "on" then
    code = codes_on[which]
  elseif state == "off" then
    code = codes_off[which]
  else
    return
  end
  os.execute("codesend " .. code .. " -l 200")
end
```

Calling this when the server gets an HTTPS POST (with valid secret and arguments) allowed me to create create [IFTTT](https://ifttt.com) applets that trigger individual lights (or all of them) on and off as I talk to Google Home. Check it out:

<center><iframe width="560" height="315" src="https://www.youtube-nocookie.com/embed/Rzu5Sy8KnO4" frameborder="0" gesture="media" allow="encrypted-media" allowfullscreen></iframe></center>

Of course, there are several ready-made solutions for this kind of thing. Most are expensive and/or obscure in implementation though (a notable exception being [IKEA's TR√ÖDFRI](https://www.iot-tests.org/2017/04/ikea-tradfri-a-smart-light-in-the-darkness-of-iot-security/)), and I'm a bit of a security freak.

![transmitter](/img/2017/12/rf_transmitter.jpg){: .right }

This hack solved my problem for a fraction of the cost (and a multiple of the fun). Sure, a prankster neighbour with an RF transmitter could have some fun with my lights - but I'd rather deal with that than have a [potential backdoor](https://www.theregister.co.uk/2016/11/10/iot_worm_can_hack_philips_hue_lightbulbs_spread_across_cities/) for a foreign nation's cryptocurrency miner inside my home network...
